{"data":{"allMdx":{"edges":[{"node":{"fields":{"slug":"/2021_11"},"tableOfContents":{"items":[{"url":"#2021_11-contents","title":"2021_11 Contents"}]}}},{"node":{"fields":{"slug":"/2021_12"},"tableOfContents":{"items":[{"url":"#2021_12-contents","title":"2021_12 Contents"}]}}},{"node":{"fields":{"slug":"/2022_01"},"tableOfContents":{"items":[{"url":"#2022_01-contents","title":"2022_01 Contents"}]}}},{"node":{"fields":{"slug":"/"},"tableOfContents":{"items":[{"url":"#today-i-learn","title":"Today I Learn"}]}}},{"node":{"fields":{"slug":"/2021_11/01_git_rebase_cherry_pick"},"tableOfContents":{"items":[{"url":"#git-rebase--cherry-pick","title":"Git Rebase & Cherry Pick"},{"url":"#git-rebase","title":"Git Rebase"},{"url":"#git-merge-종류","title":"Git Merge 종류"},{"url":"#git-cherry-pick","title":"Git Cherry Pick"}]}}},{"node":{"fields":{"slug":"/2021_11/02_git_restore_reset_revert"},"tableOfContents":{"items":[{"url":"#git-restore--reset--revert","title":"Git Restore & Reset & Revert"},{"url":"#git-restore-커밋-전-취소","title":"Git Restore: 커밋 전 취소"},{"url":"#git-reset-커밋-후-취소-히스토리-없음-특정한-commit으로-초기화","title":"Git Reset: 커밋 후 취소, 히스토리 없음 (특정한 commit으로 초기화)"},{"url":"#git-revert-커밋-후-취소-히스토리-존재","title":"Git Revert: 커밋 후 취소, 히스토리 존재"}]}}},{"node":{"fields":{"slug":"/2021_11/03_separate_ui_data_n_business_data"},"tableOfContents":{"items":[{"url":"#ui-interface와-business-interface의-분리","title":"UI Interface와 Business Interface의 분리"},{"url":"#우리는-왜-ui-interface와-business-interface를-분리해야할까","title":"우리는 왜 UI Interface와 Business Interface를 분리해야할까?"},{"url":"#어떻게-분리할-수-있을까","title":"어떻게 분리할 수 있을까?"}]}}},{"node":{"fields":{"slug":"/2021_12/01_breath_first_search_n_depth_first_search"},"tableOfContents":{"items":[{"url":"#너비우선탐색-vs-깊이우선탐색","title":"너비우선탐색 vs 깊이우선탐색"},{"url":"#그래프-탐색-알고리즘-dfsbfs","title":"그래프 탐색 알고리즘: DFS/BFS"},{"url":"#너비우선탐색-breadth-first-search","title":"너비우선탐색 (Breadth First Search)"},{"url":"#깊이우선탐색-depth-first-search","title":"깊이우선탐색 (Depth First Search)"}]}}},{"node":{"fields":{"slug":"/2021_12/02_rxjs_study_handling_multiple_pipe"},"tableOfContents":{"items":[{"url":"#rxjs-study-zip-combinelatest-withlatestfrom-forkjoin","title":"RxJS Study (zip, combineLatest, withLatestFrom, forkJoin)"},{"url":"#01-zip","title":"01. Zip"},{"url":"#02-combinelatest","title":"02. combineLatest"},{"url":"#03-withlatestfrom","title":"03. withLatestFrom"},{"url":"#04-forkjoin","title":"04. forkJoin"}]}}},{"node":{"fields":{"slug":"/2021_12/03_regular_expression"},"tableOfContents":{"items":[{"url":"#정규표현식","title":"정규표현식"},{"url":"#01-regex-regular-expression-의-약자","title":"01. Regex: Regular Expression 의 약자"},{"url":"#02-정규식-문법---groups-and-ranges","title":"02. 정규식 문법 - Groups and ranges"},{"url":"#03-정규식-문법---quantifiers","title":"03. 정규식 문법 - Quantifiers"},{"url":"#04-정규식-문법---boundary-type","title":"04. 정규식 문법 - Boundary-type"},{"url":"#04-정규식-문법---character-classes","title":"04. 정규식 문법 - Character classes"},{"url":"#05-정규식-옵션값-설명","title":"05. 정규식 옵션값 설명"},{"url":"#06-퀴즈","title":"06. 퀴즈"},{"url":"#출저","title":"출저"}]}}},{"node":{"fields":{"slug":"/2022_01/01_binary_search"},"tableOfContents":{"items":[{"url":"#binary-search-algorithms","title":"Binary Search Algorithms"},{"url":"#이진-탐색-소스코드-재귀적-구현","title":"이진 탐색 소스코드: 재귀적 구현"},{"url":"#이진-탐색-소스코드-반복문-구현","title":"이진 탐색 소스코드: 반복문 구현"},{"url":"#파라메트릭-서치parametric-search","title":"파라메트릭 서치(Parametric Search)"},{"url":"#출처","title":"출처"}]}}},{"node":{"fields":{"slug":"/2022_01/02_dynamic_programming"},"tableOfContents":{"items":[{"url":"#다이나믹-프로그래밍","title":"다이나믹 프로그래밍","items":[{"items":[{"url":"#1-다이나믹-프로그래밍","title":"1. 다이나믹 프로그래밍"},{"url":"#2-다이나믹-프로그래밍의-조건","title":"2. 다이나믹 프로그래밍의 조건"},{"url":"#3-다이나믹-프로그래밍의-대표적인-문제---피보나치-수열","title":"3. 다이나믹 프로그래밍의 대표적인 문제 - 피보나치 수열"},{"url":"#4-top-down하향식-방식---memoization","title":"4. Top-down(하향식) 방식 - Memoization"},{"url":"#5-bottom-up상향식-방식","title":"5. Bottom-Up(상향식) 방식"},{"url":"#6-다이나믹-프로그래밍-vs-분할-정복","title":"6. 다이나믹 프로그래밍 vs 분할 정복"},{"url":"#7-다이나믹-프로그래밍-문제에-접근하는-방법","title":"7. 다이나믹 프로그래밍 문제에 접근하는 방법"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/03_important_unsubscribe"},"tableOfContents":{"items":[{"url":"#unsubscribe의-중요성","title":"unsubscribe의 중요성"},{"url":"#1-문제","title":"1. 문제"},{"url":"#2-문제가-생기는-이유","title":"2. 문제가 생기는 이유"},{"url":"#3-해결방법","title":"3. 해결방법"},{"url":"#4-코드리뷰를-통해-알게된-사실","title":"4. 코드리뷰를 통해 알게된 사실"}]}}},{"node":{"fields":{"slug":"/2022_01/04_angular_dependency_injection1"},"tableOfContents":{"items":[{"url":"#angular-dependency-injection-1","title":"Angular Dependency Injection 1"},{"url":"#1의존성-주입-소개","title":"1.의존성 주입 소개"},{"url":"#2-angular에서-의존성-주입을-처음부터-설정하는-방법","title":"2. Angular에서 의존성 주입을 처음부터 설정하는 방법"},{"url":"#3-angular-의존성-주입-프로바이더란","title":"3. Angular 의존성 주입 프로바이더란?"},{"url":"#4-injection-token-소개","title":"4. Injection Token 소개"},{"url":"#5-프로바이더를-수동으로-구성하는-방법-dependency-injection-token-사용법","title":"5. 프로바이더를 수동으로 구성하는 방법 (Dependency Injection Token 사용법)"}]}}},{"node":{"fields":{"slug":"/2022_01/07_angular_dependency_injection4"},"tableOfContents":{"items":[{"url":"#angular-dependency-injection-4","title":"Angular Dependency Injection 4","items":[{"items":[{"url":"#1-종속성-주입-해결-메커니즘-구성","title":"1. 종속성 주입 해결 메커니즘 구성"},{"url":"#2-optional-데코레이터-이해","title":"2. @Optional 데코레이터 이해"},{"url":"#3-skipself-데코레이터-이해","title":"3. @SkipSelf 데코레이터 이해"},{"url":"#4-self-데코레이터-이해","title":"4. @Self 데코레이터 이해"},{"url":"#5-host-데코레이터-이해","title":"5. @Host 데코레이터 이해"},{"url":"#6-tree-shakeable-프로바이더란","title":"6. Tree Shakeable 프로바이더란?"},{"url":"#7-tree-shaking-이란","title":"7. Tree Shaking 이란?"},{"url":"#8-tree-shakeable-프로바이더-이해","title":"8. Tree Shakeable 프로바이더 이해"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/06_angular_dependency_injection3"},"tableOfContents":{"items":[{"url":"#angular-dependency-injection-3","title":"Angular Dependency Injection 3","items":[{"items":[{"url":"#1-angular-계층적-종속성-주입-이해","title":"1. Angular 계층적 종속성 주입 이해"},{"url":"#2-계층적-종속성-주입의-장점","title":"2. 계층적 종속성 주입의 장점"},{"url":"#3-컴포넌트-계층적-종속성-주입","title":"3. 컴포넌트 계층적 종속성 주입"},{"url":"#4-모듈-계층적-종속성-주입","title":"4. 모듈 계층적 종속성 주입"},{"url":"#5-모듈-vs-컴포넌트-계층적-종속성-주입","title":"5. 모듈 vs 컴포넌트 계층적 종속성 주입"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/09_xss"},"tableOfContents":{"items":[{"url":"#xss---cross-site-scripting","title":"XSS - Cross-site scripting","items":[{"items":[{"url":"#1-xsscross-site-scripting이란","title":"1. XSS(Cross-site-scripting)이란?"},{"url":"#2-xsscross-site-scripting가-일어나는-시점","title":"2. XSS(Cross-site-scripting)가 일어나는 시점"},{"url":"#3-xsscross-site-scripting가-포함되는-코드의-범위","title":"3. XSS(Cross-site-scripting)가 포함되는 코드의 범위"},{"url":"#4-xss-공격-범주","title":"4. XSS 공격 범주"},{"url":"#5-xss-해결책","title":"5. XSS 해결책"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/10_ControlValueAccessor"},"tableOfContents":{"items":[{"url":"#controlvalueaccessor","title":"ControlValueAccessor","items":[{"items":[{"url":"#1-what-is-controlvalueaccessor","title":"1. What is ControlValueAccessor?"},{"url":"#2-when-we-use-controlvalueaccessor","title":"2. When we use ControlValueAccessor?"},{"url":"#3-why-we-use-controlvalueaccessor","title":"3. Why we use ControlValueAccessor?"},{"url":"#4-controlvalueaccessor-interface","title":"4. ControlValueAccessor interface"},{"url":"#5-controlvalueaccessor-example-code","title":"5. ControlValueAccessor Example Code"},{"url":"#6-example-code","title":"6. Example Code"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/11_angular_change_detection_01"},"tableOfContents":{"items":[{"url":"#angular-detect-changes-1","title":"Angular Detect Changes 1","items":[{"items":[{"url":"#1-change-detection은-어떻게-실행되는가","title":"1. Change detection은 어떻게 실행되는가"},{"url":"#2-브라우저-기본-메커니즘-재정의하기","title":"2. 브라우저 기본 메커니즘 재정의하기"},{"url":"#3-low-level-런타임-패치는-어떻게-작동할까","title":"3. low-level 런타임 패치는 어떻게 작동할까?"},{"url":"#4-지원하는-브라우저-비동기-apis","title":"4. 지원하는 브라우저 비동기 APIs"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/12_RXJS_Bugfix_takeUntil_Subject"},"tableOfContents":{"items":[{"url":"#rxjs-bugfix--takeuntil--subject","title":"RXJS. Bugfix  takeUntil & Subject","items":[{"items":[{"url":"#1-takeuntil","title":"1. takeUntil"},{"url":"#2-subject","title":"2. Subject"},{"url":"#3-issue","title":"3. ISSUE"},{"url":"#3-modal이-destroy-되지-않는-이슈","title":"3. Modal이 destroy 되지 않는 이슈"},{"url":"#4-multiple-stream-manage-method-issue","title":"4. Multiple Stream Manage Method ISSUE"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/13_angular_detect_change_02"},"tableOfContents":{"items":[{"url":"#angular-detect-changes-2","title":"Angular Detect Changes 2","items":[{"items":[{"url":"#1-change-detection이-트리거되면-어떻게-작동할까-change-detection-tree","title":"1. change detection이 트리거되면, 어떻게 작동할까?: change detection tree"},{"url":"#2-todo-item의-change-detector는-어떻게-생겼을까","title":"2. Todo Item의 change detector는 어떻게 생겼을까?"},{"url":"#3-기본적인-change-detection-메커니즘은-어떻게-작동할까","title":"3. 기본적인 change detection 메커니즘은 어떻게 작동할까?"},{"url":"#4-중첩된-object-owner는-어떨까","title":"4. 중첩된 object owner는 어떨까?"},{"url":"#5-change-detection이-기본적으로-이와-같이-동작하는-이유는-무엇일까","title":"5. change detection이 기본적으로 이와 같이 동작하는 이유는 무엇일까?"},{"url":"#6-참조로-인한-비교는-어떻게-될까","title":"6. 참조로 인한 비교는 어떻게 될까?"},{"url":"#7-성능은-어떨까","title":"7. 성능은 어떨까?"},{"url":"#8-virtual-machine-내부-살펴보기","title":"8. virtual machine 내부 살펴보기"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/05_angular_dependency_injection2"},"tableOfContents":{"items":[{"url":"#angular-dependency-injection-2","title":"Angular Dependency Injection 2","items":[{"items":[{"url":"#1-공급자를-수동으로-구성할-필요가-없는-이유","title":"1. 공급자를 수동으로 구성할 필요가 없는 이유"},{"url":"#2-클래스-이름을-injection-token으로-사용","title":"2. 클래스 이름을 Injection Token으로 사용"},{"url":"#3-프로바이더-구성-단순화-useclass","title":"3. 프로바이더 구성 단순화: useClass"},{"url":"#4-angular-다중-값-종속성-이해","title":"4. Angular 다중 값 종속성 이해"},{"url":"#5-useexisting-프로바이더-사용-시기","title":"5. useExisting 프로바이더 사용 시기"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/08_greedy_algorithm"},"tableOfContents":{"items":[{"url":"#그리디-알고리즘","title":"그리디 알고리즘","items":[{"items":[{"url":"#1-그리디-알고리즘","title":"1. 그리디 알고리즘"},{"url":"#2-그리디-알고리즘-예시","title":"2. 그리디 알고리즘 예시"},{"url":"#3-그리디-알고리즘-코드-예시","title":"3. 그리디 알고리즘 코드 예시"}]}]}]}}},{"node":{"fields":{"slug":"/2022_01/14_angular_detect_change_03"},"tableOfContents":{"items":[{"url":"#angular-detect-changes-3","title":"Angular Detect Changes 3","items":[{"items":[{"url":"#1-onpush-change-detection-모드","title":"1. OnPush change detection 모드"},{"url":"#2-onpush는-정말로-input을-reference를-통해-비교하는-것일까","title":"2. OnPush는 정말로 input을 reference를 통해 비교하는 것일까?"},{"url":"#3-angular-앱의-구축을-단순화하기-위한-immutablejs-사용","title":"3. Angular 앱의 구축을 단순화하기 위한 Immutable.js 사용"},{"url":"#4-change-detection-루프-방지-운영-및-개발-모드","title":"4. change detection 루프 방지: 운영 및 개발 모드"},{"url":"#5-angular에서-change-detection-루프가-트리거-되는-방법","title":"5. Angular에서 change detection 루프가 트리거 되는 방법"},{"url":"#6-change-detection-이슈가-자주-발생할까","title":"6. change detection 이슈가 자주 발생할까?"},{"url":"#7-change-detection-감지-켜기끄기-및-수동-트리거","title":"7. change detection 감지 켜기/끄기 및 수동 트리거"},{"url":"#8-요약","title":"8. 요약"},{"url":"#9-change-detection에-대해-많이-알아야할까","title":"9. change detection에 대해 많이 알아야할까?"}]}]}]}}}]}}}